#+title:Data Structure and Algorithms
#+AUTHOR: Adarsha

** [[file:~/Documents/home.org][ home ]]

=Theory=
* Big O / Intro
Measure of complexity of code with respect to input.
Example:

#+begin_src python :results output
  n = 3  # Size of the datatype aka input
  for i in range(0, n):
	  for j in range(0, i):
		  print(i, j)
#+end_src

#+RESULTS:
: 1 0
: 2 0
: 2 1


This code has a complexity of =n squared=.

| *PS:* An array is just a contiguous memory space interpreted with respect to the index and size of data type.

=Theory=
* Constant Time
Also represented as O(1), meaning there is no extra computation on the literals based on the input.
Example:

#+begin_src C++ :includes <iostream>

  int main() {
	int array_size = 5, data_type_size = 4;
	int array_pos = array_size * data_type_size;
	std::cout << array_pos;
	return 0;
  }
#+end_src

#+RESULTS:
: 20


=Theory=
* Linear Search
It has a complexity of O(N)

Because for =N= number of values in an array, it needs to look for the search object =N= times for the worst case scenario.

#+begin_src C++ :includes <iostream>

  // Function
  bool linearSearch(int *arr, int val) {

	for (int i = 0; i < 5; i++) {
	  if (arr[i] == val)
		return true;
	}
	return false;
  }

  // Main
  int main() {

	int a[5] = { 1, 2, 3, 4, 5 };
	if (linearSearch(a, 3)) {
	  std::cout << "Found value in " << a;
	} else {
	  std::cout << "Did not find value!";
	}
	return 0;
  }
#+end_src

#+RESULTS:
: Found value in 0x7ffdf4b4e960

* Binary Search

#+begin_src C++ :includes <iostream>

  int binarySearch(int *arr, int val, int size) {
	int low = 0;
	int arrSize = size;
	int high = arrSize - 1;
	int ind = (low + high) / 2;
	while (low <= high) {
	  if (val < arr[ind]) {
		high = ind;
	  } else if (val > arr[ind]) {
		low = ind + 1;
	  } else {
		return ind;
	  }
	  ind = (low + (high - low) / 2);
	}
	return 0;
  }

  int main() {
	int a[4] = {1, 2, 3, 4};
	std::cout << binarySearch(a, 4, sizeof(a)/sizeof(a[0]));
	return 0;
  }
#+end_src

#+RESULTS:
: 3
